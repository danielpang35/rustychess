Summary of findings — Perft miscount diagnostics

Repository: rustychess (local clone)
Path: rustychess/rustychess

I scanned the Rust source for board storage, move generation, and perft logic. Below are the high-probability causes for perft miscounts, rationale, and an immediate fix plan.

Findings (high-probability issues)
- Sliding-attack wrap checks (bishop/rook)
  - In `src/core/constlib.rs` compute_bishop and compute_rook use wrap checks like `currpos % 8 <= 0` and `>= 7` that are inconsistent and, in spots, reversed. This can allow wraparound where sliding pieces jump from h->a file or vice versa, generating illegal moves.

- King/knight precomputed attack masks appear to use wrong file masks
  - In `src/core/movegen.rs` `init_king` applies `notAFile` on h-file squares and `notHFile` on a-file squares (masks look reversed). Similar suspicious masking appears in `init_knight`. Wrong masks produce invalid king/knight moves and affect legal move lists.

- FEN en-passant parsing is incorrect
  - In `src/core/mod.rs` `from_fen()` computes the en-passant square with odd logic (checks if rank char equals '3' specifically, otherwise adds 40). That mapping is incorrect and will set `ep_square` wrong, breaking en-passant generation and validation.

- Inconsistent use of bitboard helpers
  - A mix of `poplsb` and `trailing_zeros` is used across the code. Each assumes the bitboard is non-zero before calling; inconsistent usage can lead to unexpected results if zero bitboards are processed.

Why these break perft
- Perft counts are purely determined by move-generation correctness. Any incorrect attack mask, wrong ray generation, or wrong EP square will add or omit moves at various depths, producing mismatched counts versus reference engines.

Immediate recommended fixes
1) Fix sliding/wrap logic in `compute_bishop` and `compute_rook` (explicit file-wrapping checks). Ensure checks stop sliding when file wrap would occur.
2) Fix `init_king` and `init_knight` masks in `src/core/movegen.rs` — use `notHFile` for right-edge checks and `notAFile` for left-edge checks, and correct any extraneous hard-coded masks.
3) Fix FEN en-passant parsing in `src/core/mod.rs` to parse EP as `file_index + 8*(rank_digit - 1)` (or treat '-' specially). Set a clear sentinel for 'no ep' (e.g., 64 or 0xFF) and ensure generate/verify uses that sentinel.
4) Standardize bitboard iteration: prefer using a single helper (`poplsb`) consistently and ensure callers never call it on zero. Add defensive checks where necessary.

Suggested debug steps after fixes
- Re-run perft for small depths (1..4) and compare to known correct values.
- If mismatch remains: print the first move/branch where counts diverge (print UCI of the move and perft of that subtree) to localize the bug.
- Add unit tests for: sliding attack masks (empty and simple blocker configurations), pawn EP parsing and generation, and king/knight attack tables on edge files.

Immediate action options
- A) Apply the three focused fixes (compute_bishop/compute_rook, king/knight masks, FEN EP parse) and run `cargo run`/perft to check results.
- B) Prepare patches and leave them for you to apply and test locally.
- C) Do not change code automatically; instead provide exact diffs for you to review and apply.

Next steps I can take for you now (pick one)
- Apply fixes + run perft (A).
- Produce diffs/patches without applying (C -> B-like).
- Run targeted checks or unit tests and report where behavior diverges.

Notes / small observations
- There are debug prints and commented code across modules; fine for development but can flood logs during perft. Consider toggling verbose prints.
- `node_modules` presence is expected if `npm install` has been run — it's unrelated to Rust compilation.

If you want me to apply fixes now and run the build/perft, say: "Apply fixes and run perft". If you prefer diffs only, say: "Show diffs".

End of notes.
