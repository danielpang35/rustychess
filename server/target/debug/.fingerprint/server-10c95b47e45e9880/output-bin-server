{"$message_type":"diagnostic","message":"`await` is only allowed inside `async` functions and blocks","code":{"code":"E0728","explanation":"[`await`] has been used outside [`async`] function or [`async`] block.\n\nErroneous code example:\n\n```edition2018,compile_fail,E0728\n# use std::pin::Pin;\n# use std::future::Future;\n# use std::task::{Context, Poll};\n#\n# struct WakeOnceThenComplete(bool);\n#\n# fn wake_and_yield_once() -> WakeOnceThenComplete {\n#     WakeOnceThenComplete(false)\n# }\n#\n# impl Future for WakeOnceThenComplete {\n#     type Output = ();\n#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n#         if self.0 {\n#             Poll::Ready(())\n#         } else {\n#             cx.waker().wake_by_ref();\n#             self.0 = true;\n#             Poll::Pending\n#         }\n#     }\n# }\n#\nfn foo() {\n    wake_and_yield_once().await // `await` is used outside `async` context\n}\n```\n\n[`await`] is used to suspend the current computation until the given\nfuture is ready to produce a value. So it is legal only within\nan [`async`] context, like an `async` function or an `async` block.\n\n```edition2018\n# use std::pin::Pin;\n# use std::future::Future;\n# use std::task::{Context, Poll};\n#\n# struct WakeOnceThenComplete(bool);\n#\n# fn wake_and_yield_once() -> WakeOnceThenComplete {\n#     WakeOnceThenComplete(false)\n# }\n#\n# impl Future for WakeOnceThenComplete {\n#     type Output = ();\n#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n#         if self.0 {\n#             Poll::Ready(())\n#         } else {\n#             cx.waker().wake_by_ref();\n#             self.0 = true;\n#             Poll::Pending\n#         }\n#     }\n# }\n#\nasync fn foo() {\n    wake_and_yield_once().await // `await` is used within `async` function\n}\n\nfn bar(x: u8) -> impl Future<Output = u8> {\n    async move {\n        wake_and_yield_once().await; // `await` is used within `async` block\n        x\n    }\n}\n```\n\n[`async`]: https://doc.rust-lang.org/std/keyword.async.html\n[`await`]: https://doc.rust-lang.org/std/keyword.await.html\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":9115,"byte_end":9120,"line_start":211,"line_end":211,"column_start":50,"column_end":55,"is_primary":true,"text":[{"text":"                                                .await;","highlight_start":50,"highlight_end":55}],"label":"only allowed inside `async` functions and blocks","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":8078,"byte_end":8085,"line_start":196,"line_end":196,"column_start":69,"column_end":76,"is_primary":false,"text":[{"text":"                                        tokio::task::spawn_blocking(move || {","highlight_start":69,"highlight_end":76}],"label":"this is not `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0728]\u001b[0m\u001b[1m\u001b[97m: `await` is only allowed inside `async` functions and blocks\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:211:50\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m196\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0mo::task::spawn_blocking(move || {\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mthis is not `async`\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m211\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m    .await;\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91monly allowed inside `async` functions and blocks\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `reset_counters` found for struct `std::sync::MutexGuard<'_, Search>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":8889,"byte_end":8903,"line_start":207,"line_end":207,"column_start":55,"column_end":69,"is_primary":true,"text":[{"text":"                                                    s.reset_counters();","highlight_start":55,"highlight_end":69}],"label":"method not found in `std::sync::MutexGuard<'_, Search>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `reset_counters` found for struct `std::sync::MutexGuard<'_, Search>` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:207:55\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m207\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   s.reset_counters();\n    \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `std::sync::MutexGuard<'_, Search>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":8050,"byte_end":9211,"line_start":196,"line_end":213,"column_start":41,"column_end":47,"is_primary":true,"text":[{"text":"                                        tokio::task::spawn_blocking(move || {","highlight_start":41,"highlight_end":78},{"text":"                                            let mg_local = MoveGenerator::new();","highlight_start":1,"highlight_end":81},{"text":"                                            let searcher = searcher.clone();","highlight_start":1,"highlight_end":77},{"text":"                                            let best: Result<(EngineMove, i32), tokio::task::JoinError> =","highlight_start":1,"highlight_end":106},{"text":"                                                tokio::task::spawn_blocking(move || {","highlight_start":1,"highlight_end":86},{"text":"                                                    let mg_local = MoveGenerator::new();","highlight_start":1,"highlight_end":89},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                                    // reuse persistent searcher per socket","highlight_start":1,"highlight_end":92},{"text":"                                                    let mut s = searcher.lock().unwrap();","highlight_start":1,"highlight_end":90},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                                    // reset only per-search counters; keep TT/history/killers across moves","highlight_start":1,"highlight_end":124},{"text":"                                                    s.reset_counters();","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                                    s.search_root(&mut board_for_search, depth, &mg_local)","highlight_start":1,"highlight_end":107},{"text":"                                                })","highlight_start":1,"highlight_end":51},{"text":"                                                .await;","highlight_start":1,"highlight_end":56},{"text":"                                        })","highlight_start":1,"highlight_end":43},{"text":"                                        .await;","highlight_start":1,"highlight_end":47}],"label":"expected `Result<(Move, i32), JoinError>`, found `Result<(), JoinError>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":8050,"byte_end":9211,"line_start":196,"line_end":213,"column_start":41,"column_end":47,"is_primary":false,"text":[{"text":"                                        tokio::task::spawn_blocking(move || {","highlight_start":41,"highlight_end":78},{"text":"                                            let mg_local = MoveGenerator::new();","highlight_start":1,"highlight_end":81},{"text":"                                            let searcher = searcher.clone();","highlight_start":1,"highlight_end":77},{"text":"                                            let best: Result<(EngineMove, i32), tokio::task::JoinError> =","highlight_start":1,"highlight_end":106},{"text":"                                                tokio::task::spawn_blocking(move || {","highlight_start":1,"highlight_end":86},{"text":"                                                    let mg_local = MoveGenerator::new();","highlight_start":1,"highlight_end":89},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                                    // reuse persistent searcher per socket","highlight_start":1,"highlight_end":92},{"text":"                                                    let mut s = searcher.lock().unwrap();","highlight_start":1,"highlight_end":90},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                                    // reset only per-search counters; keep TT/history/killers across moves","highlight_start":1,"highlight_end":124},{"text":"                                                    s.reset_counters();","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                                    s.search_root(&mut board_for_search, depth, &mg_local)","highlight_start":1,"highlight_end":107},{"text":"                                                })","highlight_start":1,"highlight_end":51},{"text":"                                                .await;","highlight_start":1,"highlight_end":56},{"text":"                                        })","highlight_start":1,"highlight_end":43},{"text":"                                        .await;","highlight_start":1,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `await` expression","def_site_span":{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `Result<(rustychess::core::Move, i32), _>`\n   found enum `Result<(), _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:196:41\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m196\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m                                         tokio::ta\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m197\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                                             let m\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m198\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                                             let s\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m199\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                                             let b\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m212\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                                         })\n\u001b[1m\u001b[96m213\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                                         .await;\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Result<(Move, i32), JoinError>`, found `Result<(), JoinError>`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected enum `Result<\u001b[1m\u001b[35m(rustychess::core::Move, i32)\u001b[0m, _>`\n               found enum `Result<\u001b[1m\u001b[35m()\u001b[0m, _>`\n\n"}
